name: PR Review

# Controls when the workflow will run
on:
  pull_request:
    branches: [ "main" ]

  workflow_dispatch:

jobs:
  code-review:
    name: ChatGPT Code Review
    runs-on: ubuntu-latest
    steps:
      - name: GenAI Code Review
        uses: cirolini/genai-code-review@v2
        with:
          openai_api_key: ${{ secrets.OPENAI_API_KEY }}
          github_token: ${{ secrets.GITHUB_TOKEN }}
          github_pr_id: ${{ github.event.number }}
          openai_model: "gpt-4o" # optional
          openai_temperature: 0.5 # optional
          mode: files # files or patch
          language: en # optional, default is 'en'
          custom_prompt: "### i18n Keys\n\n### Title Case\n\n**❌ Don't**\n\n```json\n// Using inconsistent casing and vague keys leads to confusion and maintenance issues.\n\n{\n  \"profile\": {\n    \"title\": \"Your Profile\",\n    \"edit\": \"Edit Profile\",\n    \"loadingProfile\": \"Loading Profile\",\n    \"contact\": \"Contact Details\"\n  }\n}\n```\n\n**✅ Do**\n\n```json\n// Use Title Case consistently and context-aware naming in i18n keys for better readability.\n\n{\n  \"Profile\": {\n    \"PageTitle\": \"Your Profile\",\n    \"EditButton\": \"Edit Profile\",\n    \"LoadingCaption\": \"Loading Profile\",\n    \"ContactSection\": {\n      \"Title\": \"Contact Details\"\n    }\n  }\n}\n```\n\n### Grouping According to Context\n\n**❌ Don't**\n\n```json\n// Disorganized keys make it hard to locate and manage translations.\n\n{\n  \"Save\": \"Save\",\n  \"Cancel\": \"Cancel\",\n  \"ProfileTitle\": \"Your Profile\"\n}\n```\n\n**✅ Do**\n\n```json\n// Group keys based on their context for better organization.\n\n{\n  \"Buttons\": {\n    \"Save\": \"Save\",\n    \"Cancel\": \"Cancel\"\n  },\n  \"Profile\": {\n    \"PageTitle\": \"Your Profile\"\n  }\n}\n```\n\n### Context-Aware Naming (Not Naming According to Content)\n\n**❌ Don't**\n\n```json\n// Naming keys based on content can cause issues if the content changes.\n\n{\n  \"Message\": {\n    \"Success\": \"Profile updated successfully.\",\n    \"Error\": \"An error occurred.\"\n  }\n}\n```\n\n**✅ Do**\n\n```json\n// Use context-aware names that reflect the purpose or location.\n\n{\n  \"Profile\": {\n    \"Update\": {\n      \"SuccessMessage\": \"Profile updated successfully.\",\n      \"ErrorMessage\": \"An error occurred while updating your profile.\"\n    }\n  }\n}\n```\n\n---\n\n### Query and Mutation Hooks\n\n### Naming `useGetUserQuery`, `useUpdateUserMutation`\n\n**❌ Don't**\n\n```tsx\n// Destructuring the result directly can become messy with multiple queries or mutations.\n\nconst { data, isLoading, isError } = useGetUser();\nconst { mutate } = useUpdateUser();\n```\n\n**✅ Do**\n\n```tsx\n// Include 'Query' or 'Mutation' in the hook names and assign the result to a variable.\n\nconst getUserQuery = useGetUserQuery();\nconst updateUserMutation = useUpdateUserMutation();\n\n// Access properties like:\nif (getUserQuery.isLoading) { /* ... */ }\nif (updateUserMutation.isSuccess) { /* ... */ }\n```\n\n### Usage\n\n**❌ Don't**\n\n```tsx\n// Destructuring multiple query results can lead to naming conflicts and less readable code.\n\nconst { data: userData, isLoading: isUserLoading } = useGetUserQuery();\nconst { data: postsData, isLoading: isPostsLoading } = useGetPostsQuery();\n```\n\n**✅ Do**\n\n```tsx\n// Assign the query results to variables for better clarity.\n\nconst getUserQuery = useGetUserQuery();\nconst getPostsQuery = useGetPostsQuery();\n\n// Access data and states like:\nif (getUserQuery.isLoading || getPostsQuery.isLoading) { /* ... */ }\n\nconst userData = getUserQuery.data;\nconst postsData = getPostsQuery.data;\n```\n\n### Don’t Inline Function Definitions in Queries or Mutations\n\n**❌ Don't**\n\n```tsx\n// Inlining functions inside hooks reduces readability and testability.\n\nconst getUserQuery = useQuery('user', async () => {\n  const response = await fetch(`/api/user/${id}`);\n  return response.json();\n});\n```\n\n**✅ Do**\n\n```tsx\n// Define functions separately for clarity and reusability.\n\nconst fetchUser = async () => {\n  const response = await fetch(`/api/user/${id}`);\n  return response.json();\n};\n\nconst getUserQuery = useQuery('user', fetchUser);\n```\n\n### Query Keys\n\n**❌ Don't**\n\n```tsx\n// Using hard-coded query keys can lead to cache mismatches.\n\nconst getUserQuery = useQuery(['user', id], fetchUser);\n```\n\n**✅ Do**\n\n```tsx\n// Use functional query keys for consistency and maintainability.\n\nconst getUserQueryKey = (id: string) => ['user', id];\n\nconst getUserQuery = useQuery(getUserQueryKey(id), fetchUser);\n```\n\n---\n\n### HTML and Markup\n\n### Leaving New Lines Between Tags\n\n**❌ Don't**\n\n```tsx\n// Without proper spacing and indentation, the markup becomes hard to read.\n\nfunction App() {\n  return (\n    <div>\n    	<Header>\n    		<Logo/>\n    		<NavBar/>\n    	</Header>\n    	<Main>\n    		<Section>\n    			<Article/>\n    			<Aside/>\n    		</Section>\n    	</Main>\n    	<Footer>\n    		<ContactInfo/>\n    		<SocialLinks/>\n    	</Footer>\n    </div>\n  );\n}\n```\n\n**✅ Do**\n\n```tsx\n// Adding new lines and proper indentation improves readability.\n\nfunction App() {\n  return (\n    <div>\n      <Header>\n        <Logo />\n        <NavBar />\n      </Header>\n\n      <Main>\n        <Section>\n          <Article />\n          <Aside />\n        </Section>\n      </Main>\n\n      <Footer>\n        <ContactInfo />\n        <SocialLinks />\n      </Footer>\n    </div>\n  );\n}\n```\n\n---\n\n### Spacing Out Chunks of Code\n\n**❌ Don't**\n\n```tsx\n// Cluttered code blocks with inline functions reduce readability.\n\nfunction processData(data: DataType[]) {\n  const processed = data.map(item => {\n    const adjustedValue = (item.value * item.multiplier) - item.offset;\n    return adjustedValue / item.divisor;\n  }).filter(value => {\n    return value > threshold && !excludedValues.includes(value);\n  }).reduce((accumulator, value) => {\n    return accumulator + value;\n  }, 0);\n  return processed;\n}\n```\n\n**✅ Do**\n\n```tsx\n// Break down the code and add spaces between logical chunks for better readability.\n\nfunction processData(data: DataType[]) {\n  const processed = data.map(item => {\n    const adjustedValue = (item.value * item.multiplier) - item.offset;\n    return adjustedValue / item.divisor;\n  });\n\n  const filtered = processed.filter(value => {\n    return value > threshold && !excludedValues.includes(value);\n  });\n\n  const total = filtered.reduce((accumulator, value) => {\n    return accumulator + value;\n  }, 0);\n\n  return total;\n}\n```\n\n---\n\n### Commented Code\n\n**❌ Don't**\n\n```tsx\n// Leaving commented code within functions clutters the codebase and can cause confusion.\n\nfunction calculateResults(data: DataType[]) {\n  // const intermediateResults = oldCalculationMethod(data); // Deprecated method\n\n  const results = data.map(item => item.value * factor);\n  return results;\n}\n```\n\n**✅ Do**\n\n```tsx\n// Remove commented-out code to keep the codebase clean.\n\nfunction calculateResults(data: DataType[]) {\n  const results = data.map(item => item.value * factor);\n  return results;\n}\n```\n\n---\n\n### Colocating Components\n\n**❌ Don't**\n\n```\n/pages\n  /profile\n    page.tsx\n    Header.tsx\n    Details.tsx\n```\n\n**✅ Do**\n\n```\n/pages\n  /profile\n    page.tsx\n    /components\n      Header.tsx\n      Details.tsx\n```\n\n---\n\n### Documentation\n\n**❌ Don't**\n\n```tsx\n// Functions without documentation can be confusing.\n\nfunction generateReport(data: DataType[]): ReportType {\n  // complex report generation logic\n  return report;\n}\n```\n\n**✅ Do**\n\n```tsx\n// Provide a description for better understanding.\n\n/**\n * Generates a comprehensive report from the provided data.\n */\nfunction generateReport(data: DataType[]): ReportType {\n  // complex report generation logic\n  return report;\n}\n```\n\n---\n\n### Components\n\n**❌ Don't**\n\n```\n// Creating components without Storybook entries limits their testability.\n\n/src/components/Button.tsx\n```\n\n**✅ Do**\n\n```\n// Add Storybook entries and previews for better documentation and testing.\n\n/src/components/Button.tsx\n/src/components/Button.stories.tsx\n/src/style-guide/ButtonPreview.tsx\n```\n\n---\n\n### Function Args\n\n**❌ Don't**\n\n```tsx\n// Functions with multiple parameters can become unwieldy.\n\nfunction createUser(name: string, email: string, age: number, address: string) {\n  // create user logic\n}\n```\n\n**✅ Do**\n\n```tsx\n// Use an object to pass multiple parameters and start function names with verbs.\n\ninterface UserDetails {\n  name: string;\n  email: string;\n  age: number;\n  address: string;\n}\n\n/**\n * Creates a new user with the provided details.\n */\nfunction createUser(userDetails: UserDetails) {\n  // create user logic\n}\n```\n\n---\n\n### Ternary Usage (Outside of JSX)\n\n**❌ Don't**\n\n```tsx\n// Complex ternary operations reduce code clarity.\n\nconst status = user.isActive\n  ? user.isAdmin\n    ? 'Active Admin'\n    : 'Active User'\n  : 'Inactive User';\n```\n\n**✅ Do**\n\n```tsx\n// Use if-else statements for complex conditions.\n\nlet status: string;\n\nif (user.isActive) {\n  if (user.isAdmin) {\n    status = 'Active Admin';\n  } else {\n    status = 'Active User';\n  }\n} else {\n  status = 'Inactive User';\n}\n```\n\n---\n\n### useEffect (and Similar Hooks)\n\n**❌ Don't**\n\n```tsx\n// Ignoring dependencies can cause unexpected behavior.\n\n// eslint-disable-next-line react-hooks/exhaustive-deps\nuseEffect(() => {\n  fetchData();\n}, []);\n```\n\n**✅ Do**\n\n```tsx\n// Include all dependencies to ensure the effect runs correctly.\n\nuseEffect(() => {\n  fetchData();\n}, [fetchData]);\n```\n\n---\n\n### Type Safety\n\n### Don’t Use Type Coercion `as`\n\n**❌ Don't**\n\n```tsx\n// Forcing a type can hide potential errors.\n\nconst user = getUser() as UserType;\n```\n\n**✅ Do**\n\n```tsx\n// Use type guards or proper type assertions.\n\nconst userData = getUser();\n\nif (isUserType(userData)) {\n  const user: UserType = userData;\n  // proceed with user\n}\n```\n\n### Don’t Use Force Non-Null Operator `!`\n\n**❌ Don't**\n\n```tsx\n// Using '!' can lead to runtime errors if the value is null or undefined.\n\nconst username: string = user.name!;\n```\n\n**✅ Do**\n\n```tsx\n// Check for null or undefined before using the value.\n\nif (user.name !== undefined && user.name !== null) {\n  const username: string = user.name;\n}\n```\n\n---\n\n### New Page Creation\n\n**❌ Don't**\n\n```tsx\n// Using generic component names and missing metadata.\n\nexport default function Page() {\n  return <div>Welcome</div>;\n}\n```\n\n**✅ Do**\n\n```tsx\n// Name the component appropriately and add metadata.\n\nexport const metadata = {\n  title: 'Welcome Page',\n};\n\n/**\n * Renders the welcome page for new users.\n */\nexport default function WelcomePage() {\n  return <div>Welcome</div>;\n}\n```\n\n---\n\n### General Guidelines\n\n### Handle Empty States, Error States, and Loading Indicators\n\n**❌ Don't**\n\n```tsx\n// Not handling various states leads to poor user experience.\n\nfunction UserList() {\n  const getUsersQuery = useGetUsersQuery();\n\n  return (\n    <ul>\n      {getUsersQuery.data.users.map(user => (\n        <li key={user.id}>{user.name}</li>\n      ))}\n    </ul>\n  );\n}\n```\n\n**✅ Do**\n\n```tsx\n// Handle loading, error, and empty states for a better user experience.\n\nfunction UserList() {\n  const getUsersQuery = useGetUsersQuery();\n\n  if (getUsersQuery.isLoading) return <LoadingSpinner />;\n  if (getUsersQuery.isError) return <ErrorMessage />;\n\n  if (getUsersQuery.data.users.length === 0) return <EmptyState />;\n\n  return (\n    <ul>\n      {getUsersQuery.data.users.map(user => (\n        <li key={user.id}>{user.name}</li>\n      ))}\n    </ul>\n  );\n}\n```\n\n---\n\n### Test\n\n### Colocate Test Files with What You’re Testing (Including Storybook)\n\n**❌ Don't**\n\n```\n/src\n  /components\n    Button.tsx\n/tests\n  Button.test.tsx\n/stories\n  Button.stories.tsx\n```\n\n**✅ Do**\n\n```\n/src\n  /components\n    Button.tsx\n    Button.test.tsx\n    Button.stories.tsx\n```\n\n---\n\n### Imports\n\n**❌ Don't**\n\n```tsx\n// Using relative imports for common utilities leads to messy import statements.\n\nimport { formatDate } from '../../../utils/formatDate';\n```\n\n**✅ Do**\n\n```tsx\n// Use alias imports for cleaner and more maintainable code.\n\nimport { formatDate } from '@utils/formatDate';\n```\n\n---\n\n### Interfaces\n\n### Keep Component Interfaces Small and Flat\n\n**❌ Don't**\n\n```tsx\n// Large interfaces with nested objects reduce reusability.\n\ninterface ComplexUserProps {\n  user: {\n    personalInfo: {\n      name: string;\n      age: number;\n    };\n    contactInfo: {\n      email: string;\n      phone: string;\n    };\n  };\n}\n\nfunction UserCard(props: ComplexUserProps) {\n  // component logic\n}\n```\n\n**✅ Do**\n\n```tsx\n// Use flat interfaces with primitive types for better reusability.\n\ninterface UserProps {\n  name: string;\n  age: number;\n  email: string;\n  phone: string;\n}\n\nfunction UserCard(props: UserProps) {\n  // component logic\n}\n```\nprovide feedback about the code in a concise manner. list out potential issues according to these guidelines and make it easy to find the files in which they occur"

